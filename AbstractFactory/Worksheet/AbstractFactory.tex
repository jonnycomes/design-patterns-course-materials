\documentclass[11pt]{article}
\pagestyle{empty}

\usepackage{amsmath,amssymb,verbatim,graphicx}
\usepackage{rotating}

\usepackage{multicol}

\newlength{\up}\setlength{\up}{-\baselineskip}
\setlength{\textwidth}{7.5in} \setlength{\textheight}{10in}
\setlength{\topmargin}{-1in} \setlength{\oddsidemargin}{-0.5in}
\setlength{\evensidemargin}{0in}
\parindent12pt

\newcommand\blfootnote[1]{%
  \begingroup
  \renewcommand\thefootnote{}\footnote{#1}%
  \addtocounter{footnote}{-1}%
  \endgroup
}



\setlength{\columnsep}{0.25in}

\begin{document}


\noindent\emph{Name:}
\hfill
\emph{CSC-490, Winter 2020}
\blfootnote{\emph{last updated: \today}}

\vspace{-0.4in}

% \begin{minipage}[b]{0.5\textwidth}
\begin{center}
  {\huge Abstract Factory Pattern}
\end{center}

\medskip



% In order to complete this worksheet you will need the files located in the folder \texttt{Decorator} in CoCalc.

\begin{enumerate}

  \item (10pts) Consider the following story:

  \begin{itemize}

    \item There is a class called \texttt{Container} that has a data member of type \texttt{Lid}. The class \texttt{Container} could have methods like \texttt{fill()}, \texttt{empty()}, \texttt{getVolume()},$\ldots$. The class \texttt{Lid} might have methods like \texttt{open()}, \texttt{close()}, \texttt{getArea()},$\ldots$

    \item There are subclasses of those described above called \texttt{CylinderContainer}, \texttt{BowlContainer}, \texttt{CubeContainer}, \texttt{RoundLid}, and \texttt{SquareLid}. These classes have data members describing their sizes.

    \item There is a class \texttt{Factory} that has factory methods \texttt{createContainer()} and \texttt{createLid()}. When a client calls these factory methods, they should return a container and a lid \emph{that are compatible}. For example, a client should never get a \texttt{CylinderContainer} with a \texttt{SquareLid}.

  \end{itemize}

  Draw a class diagram that could be implemented for this story. Include all the factory methods in your diagram, but you don't need to include any of the methods for the lids or containers.

\newpage

  \item 
  \begin{enumerate}

    \item (2pts) Copy down the intent of the Abstract Factory pattern from the GoF:

    \vspace{0.6in}

    \item (8pts) Draw the class diagram for the Abstract Factory pattern.

    \vfill
    \vfill

    \item (5pts) Explain how the Abstract Factory pattern uses the Factory Method pattern.

    \vfill

    \item (8pts) Remember that a \emph{factory method} is a method that is responsible for creating an object, and a \emph{factory class} is a class whose single responsibility is creating objects. Determine whether each of the following statements is true or false:

    \begin{enumerate}

      \item The Abstract Factory pattern always involves a factory method?
      \item The Factory Method pattern always involves a factory method?
      \item The Abstract Factory pattern always involves a factory class?
      \item The Factory Method pattern always involves a factory class?
      \item Every factory method is part of an Abstract Factory pattern?
      \item Every factory method is part of a Factory Method pattern?
      \item Every factory class is part of an Abstract Factory pattern?
      \item Every factory class is part of a Factory Method pattern?

    \end{enumerate}

  \end{enumerate}

\newpage

  \item Recall the class \texttt{BadGuy} from our discussion on the Strategy pattern. Suppose we want to create a bad guy at a given level in the game. There should be \texttt{BadGuyFactory} with a method \texttt{createBadGuy()} that does the job. Now, remember that a bad guy is determined by its chasing and fighting behaviors. For this exercise, let's consider the following behaviors:
  \[
      \begin{tabular}{r||c|c|c}
        \emph{fights with:} & gun   & knife     &  \\\hline
        \emph{chases by:}   & boat  & swimming & running
      \end{tabular}
  \]
  That means that to create a bad guy you need to create its two behaviors. Here's the rub: only certain behaviors are appropriate for any particular level. For example, suppose Level 1 is a land level where bad guys all chase by running, and fight with either a gun or a knife. On the other hand, Level 2 is a water level where some bad guys chase in a boat with a gun and other bad guys swim with a knife. 

  \begin{enumerate}

    \item (10pts) Draw a class diagram that uses the Abstract Factory pattern implement the \texttt{BadGuyFactory}.

    \item (2pts) Include pseudocode for the implementation of the operation \texttt{createBadGuy()}.

  \end{enumerate}

  \vfill

\newpage

  \item This exercise is concerned with the program in the CoCalc folder \texttt{AbstractFactory/RandomFactories}. In that file you'll see a bare bones implementation of the Abstract Factory pattern. 

  \begin{enumerate}

    \item (10pts) Create a new subclass of \texttt{Factory} called \texttt{RandomFactory}. The factory methods in this class should return random products of the appropriate type. In other words, the first time the factory methods are called on an object they might return products of type A1 and B2, and the next time those methods are called on the \emph{same} object they might return products of type A2 and B2.

    \item (10pts) Create another concrete factory called \texttt{RandomCompatibleFactory}. For this factory, calling \texttt{createProductA()} should randomly return a product of type A1 or A2. Whenever \texttt{createProductA()} returns A1, successive calls to \texttt{createProductB()} should return B1. Similarly, if \texttt{createProductA()} returns A2, then \texttt{createProductB()} should return B2.\footnote{This type of scenario might be appropriate for something like the container-lids story. In that case the factory would return a random container (product A) and then return a lid (product B) that fits the container.}

  \end{enumerate}

\end{enumerate}


\end{document}

